{% extends 'base.html' %}

{% block title %}{{ page_title }} - Clone Hero Manager{% endblock %}

{% block content %}
<div class="container">
    {% if error %}
    <div class="alert alert-danger">
        <h2></h2>‚ö†Ô∏è Song Not Found</h2>
        <p>{{ error }}</p>
        <a href="/songs" class="btn btn-primary">‚Üê Back to Song Library</a>
    </div>
    {% elif song %}
    <div class="editor-header">
        <h1></h1>‚úèÔ∏è Edit Song</h1>
        <div class="editor-actions-top">
            <a href="/songs" class="btn btn-secondary">‚Üê Back to Library</a>
            {% if is_staged %}
            <button type="button" class="btn btn-promote" id="promoteBtn" onclick="promoteSong()">üöÄ Promote to Songs</button>
            {% endif %}
            <button type="button" class="btn btn-success" id="saveBtn" onclick="saveSong()">üíæ Save Changes</button>
        </div>
    </div>

    {% if is_staged %}
    <div class="staging-banner">
        <span class="staging-icon">üìã</span>
        <div class="staging-text">
            <strong>Staging ‚Äî Generator Folder</strong>
            <p>This song is in the <code>{{ generator_path }}</code> staging folder. Review the chart and metadata, then click <strong>üöÄ Promote to Songs</strong> to move it to your main library.</p>
        </div>
    </div>
    {% endif %}

    <div id="saveStatus" class="status-message" style="display:none;"></div>

    <!-- Core Fields -->
    <div class="editor-section">
        <h2>üéµ Core Information</h2>
        <form id="songForm">
            <div class="form-row">
                <div class="form-group">
                    <label for="title">Song Title <span class="required">*</span></label>
                    <input type="text" id="title" name="title" value="{{ song.title }}" required
                           placeholder="Enter song title">
                </div>
                <div class="form-group">
                    <label for="artist">Artist <span class="required">*</span></label>
                    <input type="text" id="artist" name="artist" value="{{ song.artist }}" required
                           placeholder="Enter artist name">
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label for="album">Album</label>
                    <input type="text" id="album" name="album" value="{{ song.album or '' }}"
                           placeholder="Enter album name">
                </div>
            </div>
        </form>
    </div>

    <!-- Song Info Section -->
    <div class="editor-section">
        <h2>üìã Song Details</h2>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-genre">Genre</label>
                <input type="text" id="meta-genre" data-meta-key="genre"
                       value="{{ song.metadata.genre if song.metadata and song.metadata.genre else '' }}"
                       placeholder="e.g. Rock, Metal, Pop">
            </div>
            <div class="form-group">
                <label for="meta-year">Year</label>
                <input type="text" id="meta-year" data-meta-key="year"
                       value="{{ song.metadata.year if song.metadata and song.metadata.year else '' }}"
                       placeholder="e.g. 2024">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-charter">Charter</label>
                <input type="text" id="meta-charter" data-meta-key="charter"
                       value="{{ song.metadata.charter if song.metadata and song.metadata.charter else '' }}"
                       placeholder="Who charted this song">
            </div>
            <div class="form-group">
                <label for="meta-icon">Icon</label>
                <input type="text" id="meta-icon" data-meta-key="icon"
                       value="{{ song.metadata.icon if song.metadata and song.metadata.icon else '' }}"
                       placeholder="Icon identifier">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-loading_phrase">Loading Phrase</label>
                <input type="text" id="meta-loading_phrase" data-meta-key="loading_phrase"
                       value="{{ song.metadata.loading_phrase if song.metadata and song.metadata.loading_phrase else '' }}"
                       placeholder="Text shown on loading screen">
            </div>
            <div class="form-group">
                <label for="meta-album_track">Album Track #</label>
                <input type="text" id="meta-album_track" data-meta-key="album_track"
                       value="{{ song.metadata.album_track if song.metadata and song.metadata.album_track else '' }}"
                       placeholder="Track number">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-playlist_track">Playlist Track #</label>
                <input type="text" id="meta-playlist_track" data-meta-key="playlist_track"
                       value="{{ song.metadata.playlist_track if song.metadata and song.metadata.playlist_track else '' }}"
                       placeholder="Playlist position">
            </div>
            <div class="form-group">
                <label for="meta-delay">Delay (ms)</label>
                <input type="text" id="meta-delay" data-meta-key="delay"
                       value="{{ song.metadata.delay if song.metadata and song.metadata.delay else '' }}"
                       placeholder="Audio delay in milliseconds">
            </div>
        </div>
    </div>

    <!-- Timing Section -->
    <div class="editor-section">
        <h2>‚è±Ô∏è Timing</h2>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-song_length">Song Length (ms)</label>
                <input type="text" id="meta-song_length" data-meta-key="song_length"
                       value="{{ song.metadata.song_length if song.metadata and song.metadata.song_length else '' }}"
                       placeholder="Duration in milliseconds">
            </div>
            <div class="form-group">
                <label for="meta-preview_start_time">Preview Start (ms)</label>
                <input type="text" id="meta-preview_start_time" data-meta-key="preview_start_time"
                       value="{{ song.metadata.preview_start_time if song.metadata and song.metadata.preview_start_time else '' }}"
                       placeholder="Preview start time">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label for="meta-video_start_time">Video Start (ms)</label>
                <input type="text" id="meta-video_start_time" data-meta-key="video_start_time"
                       value="{{ song.metadata.video_start_time if song.metadata and song.metadata.video_start_time else '' }}"
                       placeholder="Video start time">
            </div>
            <div class="form-group">
                <label for="meta-modchart">Modchart</label>
                <select id="meta-modchart" data-meta-key="modchart">
                    <option value="" {% if not song.metadata or not song.metadata.modchart %}selected{% endif %}>Not set</option>
                    <option value="True" {% if song.metadata and song.metadata.modchart == 'True' %}selected{% endif %}>Yes</option>
                    <option value="False" {% if song.metadata and song.metadata.modchart == 'False' %}selected{% endif %}>No</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Tags Section -->
    <div class="editor-section">
        <h2>üè∑Ô∏è Tags</h2>
        <p class="help-text">Tags help organise and filter your library. Add genre, decade, or custom tags. Tags are always lowercase.</p>

        <div class="tags-editor">
            <div class="tags-current" id="tagsContainer">
                {% if song.tags %}
                {% for tag in song.tags %}
                <span class="tag-chip" data-tag="{{ tag }}">
                    {{ tag }}
                    <button type="button" class="tag-remove" onclick="removeTag('{{ tag }}')" title="Remove tag">√ó</button>
                </span>
                {% endfor %}
                {% else %}
                <span class="tags-empty" id="tagsEmpty">No tags yet</span>
                {% endif %}
            </div>

            <div class="tags-add-row">
                <div class="tags-input-wrap">
                    <input type="text" id="tagInput" class="tag-input"
                           placeholder="Type a tag and press Enter‚Ä¶"
                           autocomplete="off"
                           onkeydown="handleTagKeydown(event)">
                    <div class="tag-suggestions" id="tagSuggestions" style="display:none;"></div>
                </div>
                <button type="button" class="btn btn-primary btn-sm" onclick="addTagFromInput()">+ Add</button>
                <button type="button" class="btn btn-secondary btn-sm" onclick="lookupAndAutoTag()" title="Look up metadata from MusicBrainz and auto-generate tags">üîç Auto-tag</button>
            </div>

            <div id="autoTagStatus" class="auto-tag-status" style="display:none;"></div>
        </div>
    </div>

    <!-- Difficulty Section -->
    <div class="editor-section">
        <h2>üéØ Difficulty Ratings</h2>
        <p class="help-text">Set difficulty ratings from -1 (not present) to 6 (maximum). Leave blank if not applicable.</p>

        <div class="difficulty-grid">
            {% set difficulties = [
                ('diff_guitar', 'Guitar', 'üé∏'),
                ('diff_rhythm', 'Rhythm', 'üé∏'),
                ('diff_bass', 'Bass', 'üé∏'),
                ('diff_guitar_coop', 'Guitar Co-op', 'üé∏'),
                ('diff_drums', 'Drums', 'ü•Å'),
                ('diff_drums_real', 'Real Drums', 'ü•Å'),
                ('diff_keys', 'Keys', 'üéπ'),
                ('diff_guitarghl', 'Guitar (GHL)', 'üé∏'),
                ('diff_bassghl', 'Bass (GHL)', 'üé∏'),
                ('diff_rhythm_ghl', 'Rhythm (GHL)', 'üé∏'),
                ('diff_guitar_coop_ghl', 'Guitar Co-op (GHL)', 'üé∏')
            ] %}

            {% for key, label, icon in difficulties %}
            <div class="difficulty-item">
                <label for="meta-{{ key }}">{{ icon }} {{ label }}</label>
                <input type="number" id="meta-{{ key }}" data-meta-key="{{ key }}"
                       value="{{ song.metadata[key] if song.metadata and key in song.metadata else '' }}"
                       min="-1" max="6" step="1"
                       placeholder="-1">
            </div>
            {% endfor %}""
        </div>
    </div>

    <!-- File Info (Read-only) -->
    <div class="editor-section">
        <h2>üìÇ File Information</h2>
        <div class="file-info-grid">
            <div class="file-info-item">
                <span class="file-info-label">Song ID:</span>
                <span class="file-info-value">{{ song.id }}</span>
            </div>
            {% if song.remote_path %}
            <div class="file-info-item">
                <span class="file-info-label">Nextcloud Path:</span>
                <span class="file-info-value"><code>{{ song.remote_path }}</code></span>
            </div>
            {% endif %}
            {% if song.synced_at %}
            <div class="file-info-item">
                <span class="file-info-label">Last Synced:</span>
                <span class="file-info-value">{{ song.synced_at }}</span>
            </div>
            {% elif song.created_at %}
            <div class="file-info-item">
                <span class="file-info-label">Created:</span>
                <span class="file-info-value">{{ song.created_at }}</span>
            </div>
            {% endif %}
            {% if song.updated_at %}
            <div class="file-info-item">
                <span class="file-info-label">Last Updated:</span>
                <span class="file-info-value">{{ song.updated_at }}</span>
            </div>
            {% endif %}
        </div>
    </div>

    <!-- Bottom Actions -->
    <div class="editor-actions-bottom">
        <a href="/songs" class="btn btn-secondary">‚Üê Cancel</a>
        <div class="editor-actions-right">
            {% if is_staged %}
            <button type="button" class="btn btn-promote" onclick="promoteSong()">üöÄ Promote to Songs</button>
            {% endif %}
            <button type="button" class="btn btn-primary" onclick="saveSong()">üíæ Save Changes</button>
        </div>
    </div>

    {% endif %}
</div>
{% endblock %}

{% block extra_css %}
<style>
    .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 25px;
        flex-wrap: wrap;
        gap: 15px;
    }

    .editor-header h1 {
        margin-bottom: 0;
    }

    .editor-actions-top {
        display: flex;
        gap: 10px;
    }

    .editor-section {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 25px;
        margin-bottom: 25px;
    }

    .editor-section h2 {
        margin-top: 0;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 2px solid #dee2e6;
        font-size: 1.4em;
    }

    .form-row {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        margin-bottom: 15px;
    }

    .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: bold;
        color: #2c3e50;
        font-size: 0.95em;
    }

    .required {
        color: #e74c3c;
    }

    .form-group input,
    .form-group select {
        width: 100%;
        padding: 10px 12px;
        border: 2px solid #bdc3c7;
        border-radius: 5px;
        font-size: 1em;
        transition: border-color 0.2s, box-shadow 0.2s;
        background: white;
    }

    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    .form-group input.modified {
        border-color: #f39c12;
        background: #fffbf0;
    }

    .help-text {
        color: #7f8c8d;
        font-size: 0.9em;
        margin-bottom: 15px;
    }

    .difficulty-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 15px;
    }

    .difficulty-item {
        display: flex;
        flex-direction: column;
    }

    .difficulty-item label {
        font-weight: bold;
        font-size: 0.9em;
        margin-bottom: 5px;
        color: #2c3e50;
    }

    .difficulty-item input {
        padding: 8px 10px;
        border: 2px solid #bdc3c7;
        border-radius: 5px;
        font-size: 0.95em;
        width: 100%;
        transition: border-color 0.2s;
        background: white;
    }

    .difficulty-item input:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
    }

    .file-info-grid {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .file-info-item {
        display: flex;
        gap: 12px;
        align-items: baseline;
        padding: 5px 0;
    }

    .file-info-label {
        font-weight: bold;
        color: #2c3e50;
        min-width: 120px;
    }

    .file-info-value {
        color: #495057;
        word-break: break-all;
    }

    .file-info-value code {
        background: #e9ecef;
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 0.9em;
    }

    .editor-actions-bottom {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 0;
        border-top: 2px solid #dee2e6;
        margin-top: 10px;
        flex-wrap: wrap;
        gap: 15px;
    }

    .editor-actions-right {
        display: flex;
        gap: 10px;
    }

    /* ‚îÄ‚îÄ Tags Editor ‚îÄ‚îÄ */
    .tags-editor {
        margin-top: 8px;
    }

    .tags-current {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        min-height: 36px;
        padding: 10px 12px;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 10px;
        align-items: center;
    }

    .tags-empty {
        color: #95a5a6;
        font-style: italic;
        font-size: 0.9em;
    }

    .tag-chip {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 4px 10px;
        border-radius: 14px;
        font-size: 0.85em;
        font-weight: 500;
        background: rgba(52, 152, 219, 0.12);
        color: #2980b9;
        border: 1px solid rgba(52, 152, 219, 0.25);
        animation: fadeInTag 0.2s ease;
    }

    @keyframes fadeInTag {
        from { opacity: 0; transform: scale(0.85); }
        to { opacity: 1; transform: scale(1); }
    }

    .tag-chip[data-tag^="has-"] {
        background: rgba(39, 174, 96, 0.12);
        color: #27ae60;
        border-color: rgba(39, 174, 96, 0.25);
    }

    .tag-chip[data-tag$="s"]:not([data-tag*="-"]) {
        /* Decade tags like "2020s", "1990s" ‚Äî but not hyphenated ones */
    }

    .tag-chip[data-tag="generated"] {
        background: rgba(155, 89, 182, 0.12);
        color: #8e44ad;
        border-color: rgba(155, 89, 182, 0.25);
    }

    .tag-remove {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.1em;
        cursor: pointer;
        opacity: 0.5;
        padding: 0 2px;
        line-height: 1;
        font-weight: bold;
        transition: opacity 0.15s;
    }

    .tag-remove:hover {
        opacity: 1;
    }

    .tags-add-row {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .tags-input-wrap {
        flex: 1;
        position: relative;
    }

    .tag-input {
        width: 100%;
        padding: 8px 12px;
        border: 2px solid #bdc3c7;
        border-radius: 5px;
        font-size: 0.95em;
        font-family: inherit;
    }

    .tag-input:focus {
        outline: none;
        border-color: #3498db;
    }

    .tag-suggestions {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #fff;
        border: 1px solid #dee2e6;
        border-top: none;
        border-radius: 0 0 6px 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        max-height: 180px;
        overflow-y: auto;
        z-index: 100;
    }

    .tag-suggestion-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 0.9em;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background 0.1s;
    }

    .tag-suggestion-item:hover,
    .tag-suggestion-item.active {
        background: #eef5fc;
    }

    .tag-suggestion-count {
        font-size: 0.8em;
        color: #95a5a6;
    }

    .auto-tag-status {
        margin-top: 10px;
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 0.9em;
        animation: fadeInTag 0.25s ease;
    }

    .auto-tag-status.loading {
        background: #eaf4fc;
        border: 1px solid #bee5eb;
        color: #0c5460;
    }

    .auto-tag-status.success {
        background: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }

    .auto-tag-status.error {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }

    .auto-tag-status.no-results {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
    }

    .staging-banner {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 14px 18px;
        margin-bottom: 20px;
        border: 1px solid #facc15;
        border-radius: 10px;
        background: rgba(250, 204, 21, 0.08);
    }
    .staging-icon {
        font-size: 1.6em;
        line-height: 1;
        flex-shrink: 0;
    }
    .staging-text strong {
        display: block;
        margin-bottom: 4px;
        font-size: 1.02em;
        color: #ca8a04;
    }
    .staging-text p {
        margin: 0;
        font-size: 0.92em;
        color: #6b7280;
        line-height: 1.5;
    }
    .staging-text code {
        background: rgba(0,0,0,0.06);
        padding: 1px 5px;
        border-radius: 4px;
        font-size: 0.92em;
    }

    .btn-promote {
        background: linear-gradient(135deg, #8b5cf6, #6d28d9);
        color: #fff;
        border: 1px solid #7c3aed;
    }
    .btn-promote:hover:not(:disabled) {
        background: linear-gradient(135deg, #7c3aed, #5b21b6);
        border-color: #6d28d9;
    }
    .btn-promote:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }
    .btn-promote.promoted {
        background: #22c55e;
        border-color: #22c55e;
    }

    .status-message {
        margin-bottom: 20px;
    }

    @media (max-width: 768px) {
        .editor-header {
            flex-direction: column;
            align-items: flex-start;
        }

        .form-row {
            grid-template-columns: 1fr;
        }

        .difficulty-grid {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        }

        .editor-actions-bottom {
            flex-direction: column;
            align-items: stretch;
        }

        .editor-actions-right {
            flex-direction: column;
        }
    }
</style>
{% endblock %}

{% block extra_js %}
<script>
const songId = {{ song.id if song else 'null' }};

// Track original values for change detection
const originalValues = {};

function captureOriginalValues() {
    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');
    const albumEl = document.getElementById('album');

    if (titleEl) originalValues['title'] = titleEl.value;
    if (artistEl) originalValues['artist'] = artistEl.value;
    if (albumEl) originalValues['album'] = albumEl.value;

    document.querySelectorAll('[data-meta-key]').forEach(input => {
        const key = input.getAttribute('data-meta-key');
        originalValues['meta_' + key] = input.value;
    });
}

function markModified(input) {
    const key = input.id.startsWith('meta-')
        ? 'meta_' + input.getAttribute('data-meta-key')
        : input.id;

    if (originalValues[key] !== undefined && input.value !== originalValues[key]) {
        input.classList.add('modified');
    } else {
        input.classList.remove('modified');
    }
}

// Attach change listeners
document.addEventListener('DOMContentLoaded', function() {
    captureOriginalValues();

    const allInputs = document.querySelectorAll('#songForm input, #songForm select, [data-meta-key]');
    allInputs.forEach(input => {
        input.addEventListener('input', function() {
            markModified(this);
        });
        input.addEventListener('change', function() {
            markModified(this);
        });
    });
});

function collectMetadata() {
    const metadata = {};
    document.querySelectorAll('[data-meta-key]').forEach(input => {
        const key = input.getAttribute('data-meta-key');
        const value = input.value.trim();
        if (value !== '') {
            metadata[key] = value;
        }
    });
    return metadata;
}

    async function promoteSong() {
        const promoteBtn = document.getElementById("promoteBtn");
        if (!promoteBtn) return;
        const origText = promoteBtn.textContent;
        promoteBtn.disabled = true;
        promoteBtn.textContent = "‚è≥ Moving‚Ä¶";
        try {
            const response = await fetch(`/api/songs/${songId}/promote`, {
                method: "POST",
            });
            const result = await response.json();
            if (!response.ok) {
                const errMsg = result.detail || result.error || "Promote failed";
                alert("‚ùå " + errMsg);
                promoteBtn.disabled = false;
                promoteBtn.textContent = origText;
                return;
            }
            promoteBtn.textContent = "‚úÖ Promoted!";
            promoteBtn.className = "btn btn-promote promoted";
            // Update staging banner
            const banner = document.querySelector(".staging-banner");
            if (banner) {
                banner.querySelector(".staging-text").innerHTML =
                    "<strong>‚úÖ Promoted to Songs Library</strong>" +
                    "<p>Moved to <code>" + (result.new_path || "") + "</code></p>";
                banner.style.borderColor = "#4ade80";
                banner.style.background = "rgba(74, 222, 128, 0.08)";
            }
            // Update path display in file info section
            const pathItems = document.querySelectorAll(".file-info-value code");
            pathItems.forEach(function(el) {
                if (result.new_path) el.textContent = result.new_path;
            });
            // Hide other promote buttons
            document.querySelectorAll(".btn-promote").forEach(function(btn) {
                if (btn !== promoteBtn) {
                    btn.textContent = "‚úÖ Promoted!";
                    btn.className = "btn btn-promote promoted";
                    btn.disabled = true;
                }
            });
        } catch (err) {
            alert("‚ùå Network error: " + err.message);
            promoteBtn.disabled = false;
            promoteBtn.textContent = origText;
        }
    }

    async function saveSong() {
    if (!songId) return;

    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');
    const albumEl = document.getElementById('album');
    const statusDiv = document.getElementById('saveStatus');
    const saveBtn = document.getElementById('saveBtn');

    // Validate required fields
    if (!titleEl.value.trim()) {
        titleEl.focus();
        statusDiv.innerHTML = '<div class="alert alert-danger">‚ùå Song title is required.</div>';
        statusDiv.style.display = 'block';
        return;
    }
    if (!artistEl.value.trim()) {
        artistEl.focus();
        statusDiv.innerHTML = '<div class="alert alert-danger">‚ùå Artist name is required.</div>';
        statusDiv.style.display = 'block';
        return;
    }

    saveBtn.disabled = true;
    saveBtn.textContent = '‚è≥ Saving...';
    statusDiv.innerHTML = '<div class="alert alert-info">üíæ Saving changes...</div>';
    statusDiv.style.display = 'block';

    const payload = {
        title: titleEl.value.trim(),
        artist: artistEl.value.trim(),
        album: albumEl.value.trim() || null,
        metadata: collectMetadata()
    };

    try {
        const response = await fetch(`/api/songs/${songId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (response.ok) {
            statusDiv.innerHTML = '<div class="alert alert-success">‚úÖ Song updated successfully! The song.ini file on disk has also been updated.</div>';

            // Reset modification tracking
            captureOriginalValues();
            document.querySelectorAll('.modified').forEach(el => el.classList.remove('modified'));

            showNotification('Song saved successfully!', 'success');
        } else {
            const errMsg = result.detail || result.error || 'Update failed';
            statusDiv.innerHTML = `<div class="alert alert-danger">‚ùå Error: ${errMsg}</div>`;
        }
    } catch (error) {
        statusDiv.innerHTML = `<div class="alert alert-danger">‚ùå Network error: ${error.message}</div>`;
    } finally {
        saveBtn.disabled = false;
        saveBtn.textContent = 'üíæ Save Changes';
    }

    // Scroll to status message
    statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Warn before leaving with unsaved changes
window.addEventListener('beforeunload', function(e) {
    const modified = document.querySelectorAll('.modified');
    if (modified.length > 0) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// Keyboard shortcut: Ctrl+S to save
document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveSong();
    }
});

// ‚îÄ‚îÄ Tag Management ‚îÄ‚îÄ

// All existing tags in the library (for autocomplete)
const allKnownTags = {{ all_tags | tojson }};
let suggestIndex = -1;

function getCurrentTags() {
    const chips = document.querySelectorAll('#tagsContainer .tag-chip');
    return Array.from(chips).map(c => c.getAttribute('data-tag'));
}

function renderTagChip(tag) {
    const span = document.createElement('span');
    span.className = 'tag-chip';
    span.setAttribute('data-tag', tag);
    span.textContent = tag + ' ';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tag-remove';
    btn.title = 'Remove tag';
    btn.textContent = '√ó';
    btn.onclick = function() { removeTag(tag); };
    span.appendChild(btn);
    return span;
}

async function addTag(tag) {
    tag = tag.trim().toLowerCase();
    if (!tag) return;

    const current = getCurrentTags();
    if (current.indexOf(tag) !== -1) return; // already present

    try {
        const resp = await fetch('/api/songs/' + songId + '/tags', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ add: [tag] })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        refreshTagsUI(data.tags);
    } catch (err) {
        showNotification('Failed to add tag: ' + err.message, 'danger');
    }
}

async function removeTag(tag) {
    try {
        const resp = await fetch('/api/songs/' + songId + '/tags', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ remove: [tag] })
        });
        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();
        refreshTagsUI(data.tags);
    } catch (err) {
        showNotification('Failed to remove tag: ' + err.message, 'danger');
    }
}

function refreshTagsUI(tags) {
    const container = document.getElementById('tagsContainer');
    container.innerHTML = '';
    if (!tags || tags.length === 0) {
        const empty = document.createElement('span');
        empty.className = 'tags-empty';
        empty.id = 'tagsEmpty';
        empty.textContent = 'No tags yet';
        container.appendChild(empty);
    } else {
        tags.forEach(function(tag) {
            container.appendChild(renderTagChip(tag));
        });
    }
}

function addTagFromInput() {
    const input = document.getElementById('tagInput');
    const val = input.value.trim();
    if (val) {
        // Support comma-separated tags
        val.split(',').forEach(function(t) {
            addTag(t);
        });
        input.value = '';
        hideSuggestions();
    }
}

function handleTagKeydown(e) {
    const suggestionsEl = document.getElementById('tagSuggestions');
    const items = suggestionsEl.querySelectorAll('.tag-suggestion-item');

    if (e.key === 'Enter') {
        e.preventDefault();
        if (suggestIndex >= 0 && suggestIndex < items.length) {
            const tag = items[suggestIndex].getAttribute('data-tag');
            addTag(tag);
            document.getElementById('tagInput').value = '';
            hideSuggestions();
        } else {
            addTagFromInput();
        }
        return;
    }

    if (e.key === 'ArrowDown') {
        e.preventDefault();
        suggestIndex = Math.min(suggestIndex + 1, items.length - 1);
        highlightSuggestion(items);
        return;
    }

    if (e.key === 'ArrowUp') {
        e.preventDefault();
        suggestIndex = Math.max(suggestIndex - 1, -1);
        highlightSuggestion(items);
        return;
    }

    if (e.key === 'Escape') {
        hideSuggestions();
        return;
    }

    // Debounce the suggestion update
    setTimeout(function() { showSuggestions(); }, 50);
}

function showSuggestions() {
    const input = document.getElementById('tagInput');
    const val = input.value.trim().toLowerCase();
    const suggestionsEl = document.getElementById('tagSuggestions');

    if (!val) {
        hideSuggestions();
        return;
    }

    const currentTags = getCurrentTags();
    const matches = allKnownTags.filter(function(t) {
        return t.tag.indexOf(val) !== -1 && currentTags.indexOf(t.tag) === -1;
    }).slice(0, 8);

    if (matches.length === 0) {
        hideSuggestions();
        return;
    }

    suggestIndex = -1;
    suggestionsEl.innerHTML = '';
    matches.forEach(function(t) {
        const item = document.createElement('div');
        item.className = 'tag-suggestion-item';
        item.setAttribute('data-tag', t.tag);

        const nameSpan = document.createElement('span');
        nameSpan.textContent = t.tag;
        item.appendChild(nameSpan);

        const countSpan = document.createElement('span');
        countSpan.className = 'tag-suggestion-count';
        countSpan.textContent = t.count + ' song' + (t.count !== 1 ? 's' : '');
        item.appendChild(countSpan);

        item.onclick = function() {
            addTag(t.tag);
            input.value = '';
            hideSuggestions();
        };
        suggestionsEl.appendChild(item);
    });
    suggestionsEl.style.display = 'block';
}

function highlightSuggestion(items) {
    items.forEach(function(item, i) {
        item.classList.toggle('active', i === suggestIndex);
    });
}

function hideSuggestions() {
    suggestIndex = -1;
    document.getElementById('tagSuggestions').style.display = 'none';
}

// Close suggestions when clicking outside
document.addEventListener('click', function(e) {
    if (!e.target.closest('.tags-input-wrap')) {
        hideSuggestions();
    }
});

// ‚îÄ‚îÄ Auto-tag via MusicBrainz lookup ‚îÄ‚îÄ
async function lookupAndAutoTag() {
    const titleEl = document.getElementById('title');
    const artistEl = document.getElementById('artist');
    const statusEl = document.getElementById('autoTagStatus');

    const title = titleEl ? titleEl.value.trim() : '';
    const artist = artistEl ? artistEl.value.trim() : '';

    if (!title) {
        statusEl.className = 'auto-tag-status error';
        statusEl.textContent = '‚ö†Ô∏è Song title is required for lookup.';
        statusEl.style.display = 'block';
        return;
    }

    statusEl.className = 'auto-tag-status loading';
    statusEl.textContent = 'üîç Looking up metadata on MusicBrainz‚Ä¶';
    statusEl.style.display = 'block';

    try {
        const resp = await fetch('/api/lookup-metadata', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title, artist: artist })
        });

        if (!resp.ok) throw new Error('HTTP ' + resp.status);
        const data = await resp.json();

        if (!data.found) {
            statusEl.className = 'auto-tag-status no-results';
            statusEl.textContent = '‚ö†Ô∏è No match found on MusicBrainz for "' + title + '"' + (artist ? ' by ' + artist : '');
            return;
        }

        const suggestedTags = data.suggested_tags || [];
        if (suggestedTags.length === 0) {
            statusEl.className = 'auto-tag-status no-results';
            statusEl.textContent = '‚ö†Ô∏è Metadata found but no tags could be generated.';
            return;
        }

        // Add all suggested tags
        const addResp = await fetch('/api/songs/' + songId + '/tags', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ add: suggestedTags })
        });

        if (!addResp.ok) throw new Error('Failed to save tags');
        const tagData = await addResp.json();
        refreshTagsUI(tagData.tags);

        const newCount = suggestedTags.length;
        let msg = '‚úÖ Added ' + newCount + ' tag' + (newCount !== 1 ? 's' : '') + ': ' + suggestedTags.join(', ');
        if (data.album) {
            msg += '  ‚Ä¢  Album: ' + data.album;
        }
        if (data.year) {
            msg += ' (' + data.year + ')';
        }
        statusEl.className = 'auto-tag-status success';
        statusEl.textContent = msg;

        // Also fill in album/year/genre fields if empty
        const albumEl = document.getElementById('album');
        if (albumEl && !albumEl.value.trim() && data.album) {
            albumEl.value = data.album;
            albumEl.classList.add('modified');
        }
        const yearEl = document.getElementById('meta-year');
        if (yearEl && !yearEl.value.trim() && data.year) {
            yearEl.value = data.year;
            yearEl.classList.add('modified');
        }
        const genreEl = document.getElementById('meta-genre');
        if (genreEl && !genreEl.value.trim() && data.genre) {
            genreEl.value = data.genre;
            genreEl.classList.add('modified');
        }

    } catch (err) {
        statusEl.className = 'auto-tag-status error';
        statusEl.textContent = '‚ùå Lookup failed: ' + err.message;
    }
}
</script>
{% endblock %}
